name: Apply Branch Protection Rules

on:
  workflow_dispatch:
    inputs:
      repositories:
        description: 'List of repositories (comma-separated, e.g., "repo1,repo2,repo3")'
        required: false
        type: string
      prefix:
        description: 'Repository prefix to filter by (e.g., "oof-latax-")'
        required: false
        default: 'oof-latax-'
        type: string
      organization:
        description: 'GitHub organization name'
        required: true
        default: 'CityOfLosAngeles'
        type: string

jobs:
  # Use the reusable base workflow to get repository information
  setup:
    uses: ./.github/workflows/reusable-base.yml
    with:
      repositories: ${{ github.event.inputs.repositories }}
      prefix: ${{ github.event.inputs.prefix }}
      organization: ${{ github.event.inputs.organization }}
    secrets:
      PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
  
  # Apply branch protection rules to repositories
  apply-branch-rules:
    needs: setup
    runs-on: ubuntu-latest
    
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: |
          npm init -y
          npm install @octokit/rest
      
      - name: Create branch protection script
        run: |
          cat > apply-branch-rules.js << 'EOF'
          const { Octokit } = require('@octokit/rest');
          
          // Initialize Octokit with GitHub token
          const octokit = new Octokit({
            auth: process.env.GITHUB_TOKEN,
          });
          
          // Get repositories and organization from environment
          const org = process.env.ORGANIZATION;
          const repos = JSON.parse(process.env.REPOSITORIES);
          
          // Color codes for console output
          const colors = {
            red: '\x1b[31m',
            green: '\x1b[32m',
            yellow: '\x1b[33m',
            blue: '\x1b[34m',
            magenta: '\x1b[35m',
            reset: '\x1b[0m'
          };
          
          // Counters for summary reporting
          const counters = {
            totalRepos: repos.length,
            rulesApplied: 0,
            rulesFailed: 0
          };
          
          // Branch naming rule configuration
          const branchNamingRule = {
            name: "Branch-Naming-Rule",
            target: "branch",
            enforcement: "active",
            conditions: {
              ref_name: {
                exclude: [
                  "refs/heads/main",
                  "refs/heads/feature/*",
                  "refs/heads/bugfix/*",
                  "refs/heads/hotfix/*",
                  "refs/heads/release/*",
                  "refs/heads/develop"
                ],
                include: []
              }
            },
            rules: [
              {
                type: "non_fast_forward"
              },
              {
                type: "creation"
              }
            ],
            bypass_actors: []
          };
          
          // Prevent deletion rule configuration
          const preventDeleteRule = {
            name: "Prevent-Accidental-Delete-Main-Develop",
            target: "branch",
            enforcement: "active",
            conditions: {
              ref_name: {
                exclude: [],
                include: [
                  "refs/heads/main",
                  "refs/heads/develop"
                ]
              }
            },
            rules: [
              {
                type: "deletion"
              },
              {
                type: "non_fast_forward"
              },
              {
                type: "pull_request",
                parameters: {
                  required_approving_review_count: 1,
                  dismiss_stale_reviews_on_push: false,
                  require_code_owner_review: false,
                  require_last_push_approval: false,
                  required_review_thread_resolution: false,
                  automatic_copilot_code_review_enabled: false,
                  allowed_merge_methods: [
                    "merge",
                    "squash",
                    "rebase"
                  ]
                }
              }
            ],
            bypass_actors: []
          };
          
          /**
           * Create or update a ruleset in a repository
           * @param {string} repo Repository name
           * @param {object} ruleConfig Ruleset configuration
           * @returns {Promise<boolean>} Success status
           */
          async function applyRuleset(repo, ruleConfig) {
            console.log(`${colors.blue}Applying ruleset '${ruleConfig.name}' to ${org}/${repo}${colors.reset}`);
            
            try {
              // Check if rule already exists
              const existingRules = await octokit.request('GET /repos/{owner}/{repo}/rulesets', {
                owner: org,
                repo: repo
              });
              
              const existingRule = existingRules.data.find(rule => rule.name === ruleConfig.name);
              
              if (existingRule) {
                console.log(`${colors.yellow}Rule '${ruleConfig.name}' already exists (ID: ${existingRule.id}). Updating...${colors.reset}`);
                
                const response = await octokit.request('PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}', {
                  owner: org,
                  repo: repo,
                  ruleset_id: existingRule.id,
                  ...ruleConfig
                });
                
                if (response.status >= 200 && response.status < 300) {
                  console.log(`${colors.green}‚úÖ Updated ruleset '${ruleConfig.name}' successfully${colors.reset}`);
                  return true;
                } else {
                  console.error(`${colors.red}‚ùå Failed to update ruleset '${ruleConfig.name}'${colors.reset}`);
                  return false;
                }
              } else {
                const response = await octokit.request('POST /repos/{owner}/{repo}/rulesets', {
                  owner: org,
                  repo: repo,
                  ...ruleConfig
                });
                
                if (response.status >= 200 && response.status < 300) {
                  console.log(`${colors.green}‚úÖ Created ruleset '${ruleConfig.name}' successfully${colors.reset}`);
                  return true;
                } else {
                  console.error(`${colors.red}‚ùå Failed to create ruleset '${ruleConfig.name}'${colors.reset}`);
                  return false;
                }
              }
            } catch (error) {
              console.error(`${colors.red}‚ùå Error applying ruleset '${ruleConfig.name}': ${error.message}${colors.reset}`);
              if (error.response && error.response.data) {
                console.error(`${colors.red}Details: ${JSON.stringify(error.response.data, null, 2)}${colors.reset}`);
              }
              return false;
            }
          }
          
          /**
           * Process a single repository
           * @param {string} repo Repository name
           */
          async function processRepository(repo) {
            console.log(`\n${colors.magenta}üîÑ PROCESSING: ${org}/${repo}${colors.reset}`);
            
            let success = 0;
            
            // Apply branch naming rule
            if (await applyRuleset(repo, branchNamingRule)) {
              success++;
            }
            
            // Apply prevent deletion rule
            if (await applyRuleset(repo, preventDeleteRule)) {
              success++;
            }
            
            // Count this repository as successfully processed if at least one rule was applied
            if (success > 0) {
              counters.rulesApplied++;
              console.log(`${colors.green}‚úÖ Successfully applied ${success}/2 rules to ${org}/${repo}${colors.reset}`);
            } else {
              counters.rulesFailed++;
              console.log(`${colors.red}‚ùå Failed to apply any rules to ${org}/${repo}${colors.reset}`);
            }
          }
          
          /**
           * Main function
           */
          async function main() {
            try {
              console.log(`${colors.blue}Starting branch protection rules application for ${repos.length} repositories${colors.reset}`);
              
              // Process each repository
              for (const repo of repos) {
                await processRepository(repo);
              }
              
              // Print summary
              console.log(`\n${colors.blue}‚ÑπÔ∏è SUMMARY${colors.reset}`);
              console.log(`${colors.blue}‚ÑπÔ∏è Total repositories processed: ${counters.totalRepos}${colors.reset}`);
              console.log(`${colors.green}‚úÖ Repositories with rules applied successfully: ${counters.rulesApplied}${colors.reset}`);
              console.log(`${colors.red}‚ùå Repositories with failed rule application: ${counters.rulesFailed}${colors.reset}`);
            } catch (error) {
              console.error(`${colors.red}‚ùå Error in main function: ${error.message}${colors.reset}`);
              process.exit(1);
            }
          }
          
          // Run the main function
          main();
          EOF
      
      - name: Apply branch protection rules
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
          ORGANIZATION: ${{ github.event.inputs.organization }}
          REPOSITORIES: ${{ needs.setup.outputs.repos_json }}
        run: node apply-branch-rules.js